# frozen_string_literal: true

require "minitest/autorun"
require "teek/mgba"
require "tempfile"
require "tmpdir"

class TestMGBACore < Minitest::Test
  # Generated by: ruby teek-mgba/scripts/generate_test_rom.rb
  TEST_ROM = File.expand_path("fixtures/test.gba", __dir__)

  def setup
    skip "Run: ruby teek-mgba/scripts/generate_test_rom.rb" unless File.exist?(TEST_ROM)
    @core = Teek::MGBA::Core.new(TEST_ROM)
  end

  def teardown
    @core&.destroy unless @core.nil? || @core.destroyed?
  end

  # -- Dimensions --------------------------------------------------------------

  def test_width
    assert_equal 240, @core.width
  end

  def test_height
    assert_equal 160, @core.height
  end

  # -- Title -------------------------------------------------------------------

  def test_title
    assert_equal "TEEKTEST", @core.title
  end

  # -- ROM metadata ------------------------------------------------------------

  def test_game_code
    code = @core.game_code
    # mGBA prefixes with platform: "AGB-" for GBA
    assert_equal "AGB-BTKE", code
    refute_includes code, "\0", "game_code must not contain null bytes"
  end

  def test_maker_code
    maker = @core.maker_code
    assert_equal "01", maker
    refute_includes maker, "\0", "maker_code must not contain null bytes"
  end

  def test_title_no_null_bytes
    title = @core.title
    assert_equal "TEEKTEST", title
    refute_includes title, "\0", "title must not contain null bytes"
  end

  def test_checksum
    crc = @core.checksum
    assert_kind_of Integer, crc
    assert crc > 0
  end

  def test_platform
    assert_equal "GBA", @core.platform
  end

  def test_rom_size
    size = @core.rom_size
    assert_kind_of Integer, size
    assert size > 0
  end

  # -- Lifecycle ---------------------------------------------------------------

  def test_not_destroyed_initially
    refute @core.destroyed?
  end

  def test_destroy
    @core.destroy
    assert @core.destroyed?
  end

  def test_double_destroy_is_safe
    @core.destroy
    @core.destroy
    assert @core.destroyed?
  end

  def test_methods_raise_after_destroy
    @core.destroy
    assert_raises(RuntimeError) { @core.run_frame }
    assert_raises(RuntimeError) { @core.video_buffer }
    assert_raises(RuntimeError) { @core.video_buffer_argb }
    assert_raises(RuntimeError) { @core.audio_buffer }
    assert_raises(RuntimeError) { @core.set_keys(0) }
    assert_raises(RuntimeError) { @core.width }
    assert_raises(RuntimeError) { @core.height }
    assert_raises(RuntimeError) { @core.title }
    assert_raises(RuntimeError) { @core.game_code }
    assert_raises(RuntimeError) { @core.maker_code }
    assert_raises(RuntimeError) { @core.checksum }
    assert_raises(RuntimeError) { @core.platform }
    assert_raises(RuntimeError) { @core.rom_size }
    assert_raises(RuntimeError) { @core.save_state_to_file("/tmp/x.ss") }
    assert_raises(RuntimeError) { @core.load_state_from_file("/tmp/x.ss") }
  end

  # -- Frame emulation ---------------------------------------------------------

  def test_run_frame
    @core.run_frame
  end

  def test_video_buffer_size
    @core.run_frame
    buf = @core.video_buffer
    assert_kind_of String, buf
    assert_equal 240 * 160 * 4, buf.bytesize
  end

  def test_video_buffer_argb_size
    @core.run_frame
    buf = @core.video_buffer_argb
    assert_kind_of String, buf
    assert_equal 240 * 160 * 4, buf.bytesize
  end

  def test_video_buffer_argb_swaps_r_and_b
    @core.run_frame
    raw  = @core.video_buffer.unpack('V*')
    argb = @core.video_buffer_argb.unpack('V*')
    assert_equal raw.size, argb.size
    # Verify R↔B swap for first non-zero pixel
    idx = raw.index { |px| px != 0 } || 0
    px = raw[idx]
    expected = (px & 0xFF00FF00) |
               ((px & 0x000000FF) << 16) |
               ((px & 0x00FF0000) >> 16)
    assert_equal expected, argb[idx]
  end

  def test_audio_buffer_is_stereo_int16
    @core.run_frame
    buf = @core.audio_buffer
    assert_kind_of String, buf
    assert_equal 0, buf.bytesize % 4, "should be stereo int16 (4 bytes per frame)"
  end

  def test_multiple_frames
    10.times { @core.run_frame }
    assert_equal 240 * 160 * 4, @core.video_buffer.bytesize
  end

  # -- Input -------------------------------------------------------------------

  def test_set_keys
    @core.set_keys(Teek::MGBA::KEY_A | Teek::MGBA::KEY_START)
    @core.run_frame
    @core.set_keys(0)
    @core.run_frame
  end

  # -- Save files --------------------------------------------------------------

  def test_save_dir_creates_sav_file
    Dir.mktmpdir("teek-saves") do |dir|
      core = Teek::MGBA::Core.new(TEST_ROM, dir)
      core.run_frame
      core.destroy
      sav = Dir.glob(File.join(dir, "*.sav"))
      assert_equal 1, sav.size, "Expected a .sav file in #{dir}"
    end
  end

  def test_save_dir_nil_uses_rom_directory
    # When save_dir is nil, saves go alongside the ROM — just verify no crash
    core = Teek::MGBA::Core.new(TEST_ROM)
    core.run_frame
    core.destroy
  end

  # -- Save states -------------------------------------------------------------

  def test_save_state_to_file
    @core.run_frame
    Dir.mktmpdir("teek-states") do |dir|
      path = File.join(dir, "test.ss1")
      assert @core.save_state_to_file(path), "save_state_to_file should return true"
      assert File.exist?(path), "State file should exist"
      assert File.size(path) > 0, "State file should not be empty"
    end
  end

  def test_load_state_from_file
    # Run several frames to reach a known state
    10.times { @core.run_frame }

    Dir.mktmpdir("teek-states") do |dir|
      path = File.join(dir, "test.ss1")

      # Save state at frame 10
      assert @core.save_state_to_file(path)

      # Run more frames to advance past the saved state
      10.times { @core.run_frame }

      # Load state — should succeed and restore core to a valid state
      assert @core.load_state_from_file(path), "load_state_from_file should return true"

      # Core should be functional after loading: run a frame without crashing
      @core.run_frame
      buf = @core.video_buffer
      assert_equal 240 * 160 * 4, buf.bytesize, "Video buffer should be valid after state load"
    end
  end

  def test_load_state_nonexistent_returns_false
    result = @core.load_state_from_file("/no/such/state.ss1")
    refute result, "load_state_from_file should return false for missing file"
  end

  def test_save_state_raises_on_bad_path
    @core.run_frame
    assert_raises(RuntimeError) { @core.save_state_to_file("/no/such/dir/state.ss1") }
  end

  def test_save_state_round_trip_preserves_state
    # Run to frame 10, save, continue to frame 20, load, run 1 frame.
    # If state was truly restored, the frame after load should match
    # frame 11 from a fresh run.
    10.times { @core.run_frame }

    Dir.mktmpdir("teek-states") do |dir|
      path = File.join(dir, "test.ss1")
      assert @core.save_state_to_file(path)

      # Capture frame 11 from saved state
      @core.run_frame
      buf_frame_11 = @core.video_buffer

      # Reload state (back to frame 10)
      assert @core.load_state_from_file(path)

      # Run 1 frame from restored state (should be frame 11 again)
      @core.run_frame
      buf_restored_11 = @core.video_buffer

      assert_equal buf_frame_11, buf_restored_11,
        "Frame after load should match frame after save point"
    end
  end

  # -- Error handling ----------------------------------------------------------

  def test_nonexistent_file
    assert_raises(ArgumentError) { Teek::MGBA::Core.new("/no/such/game.gba") }
  end

  def test_invalid_extension
    Tempfile.create(["bad", ".txt"]) do |f|
      f.write("not a rom")
      f.flush
      assert_raises(ArgumentError) { Teek::MGBA::Core.new(f.path) }
    end
  end
end
